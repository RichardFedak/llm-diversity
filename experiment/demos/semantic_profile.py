from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from ollama import chat
from typing import List
from pydantic import BaseModel

class UserProfile(BaseModel):
    genres: str
    description: str

movies = [
    {"title": "Superbad", "genres": "Comedy", "description": "High school friends try to enjoy a wild night before graduation."},
    {"title": "Step Brothers", "genres": "Comedy", "description": "Two immature adults become stepbrothers and clash hilariously."},
    {"title": "The Hangover", "genres": "Comedy", "description": "Friends lose the groom during a wild bachelor party in Vegas."},
    {"title": "Anchorman", "genres": "Comedy", "description": "An arrogant news anchor struggles to maintain his fame and control."},
    {"title": "Dumb and Dumber", "genres": "Comedy, Adventure", "description": "Two clueless friends go on a cross-country trip to return a briefcase."},
    {"title": "The Hangover Part II", "genres": "Comedy", "description": "The same friends get into another hilarious predicament while in Thailand."},

    {"title": "Mad Max: Fury Road", "genres": "Action, Adventure", "description": "In a post-apocalyptic wasteland, a drifter helps a rebellious woman flee from a tyrant with his war rig."},
    {"title": "John Wick", "genres": "Action, Thriller", "description": "A retired hitman seeks vengeance on those who wronged him, unleashing an unstoppable wave of violence."},
    {"title": "Gladiator", "genres": "Action, Drama", "description": "A betrayed Roman general fights for vengeance as a gladiator in the Colosseum."},
    {"title": "The Dark Knight", "genres": "Action, Crime, Drama", "description": "Batman faces off against the Joker, a criminal mastermind spreading chaos across Gotham."},
    {"title": "Die Hard", "genres": "Action, Thriller", "description": "A New York cop battles terrorists who take over a skyscraper during a Christmas party."},
    {"title": "The Bourne Identity", "genres": "Action, Mystery, Thriller", "description": "A man with amnesia discovers he's a highly trained operative while being hunted by assassins."}
]


users = {
    "User A (Comedy)": [
        {"title": "Superbad", "genres": "Comedy", "description": "High school friends try to enjoy a wild night before graduation."},
        {"title": "Step Brothers", "genres": "Comedy", "description": "Two immature adults become stepbrothers and clash hilariously."},
        {"title": "The Hangover", "genres": "Comedy", "description": "Friends lose the groom during a wild bachelor party in Vegas."},
    ],
    "User B (Action)": [
        {"title": "Mad Max: Fury Road", "genres": "Action, Adventure", "description": "In a post-apocalyptic wasteland, a drifter helps a rebellious woman flee from a tyrant with his war rig."},
        {"title": "John Wick", "genres": "Action, Thriller", "description": "A retired hitman seeks vengeance on those who wronged him, unleashing an unstoppable wave of violence."},
        {"title": "Gladiator", "genres": "Action, Drama", "description": "A betrayed Roman general fights for vengeance as a gladiator in the Colosseum."},
   ]
}

model = SentenceTransformer('all-MiniLM-L6-v2')
# model = SentenceTransformer('nli-roberta-large')

genre_embeddings = model.encode([m['genres'] for m in movies])
description_embeddings = model.encode([m['description'] for m in movies])

# Weigthed embedding ? Maybe not needed here, only makes sense for user profile ?
# movie_embeddings = 0.7 * genre_embeddings + 0.3 * description_embeddings
movie_embeddings = genre_embeddings + description_embeddings

print("Embedding done")

def recommend_for_user(user_name, liked_movies):
    liked_titles_only = [m["title"] for m in liked_movies]
    movie_titles_formatted = "\n".join(f"- {m['title']}" for m in liked_movies)

    llama_prompt = f"""
The user enjoys the following movies:

{movie_titles_formatted}

Based on these, write a synthetic movie-style entry that represents the user's movie taste. 
Return a short JSON with 'genres' and 'description'. 
Genres should be comma-separated keywords. 
The description should match the tone and structure of actual movie descriptions in the dataset.
"""

    response = chat(
        messages=[
            {"role": "system", "content": "You are a helpful assistant that creates user preference profiles for movie recommendation systems. You always return output in a format that matches movie metadata: genres and a description. Your output is meant to be used in embedding-based search."},
            {"role": "user", "content": llama_prompt}
        ],
        model="llama3.2",
        format=UserProfile.model_json_schema(),
    )
    semantic_profile = UserProfile.model_validate_json(response.message.content)
    
    print(f"\n=== {user_name} ===")
    print("Semantic profile generated by LLM:")
    print(semantic_profile)

    profile_embedding_genres = model.encode([semantic_profile.genres])
    profile_embedding_description = model.encode([semantic_profile.description])

    print(profile_embedding_genres.shape)
    print("---------")
    print(profile_embedding_description.shape)

    # Weighted embedding ? TODO: Based on user (diversity) perception ?
    profile_embedding = 0.7 * profile_embedding_genres + 0.3 * profile_embedding_description

    similarities = cosine_similarity(profile_embedding, movie_embeddings)[0]
    top_indices = similarities.argsort()[::-1]

    recommended_movies = []
    for idx in top_indices:
        movie = movies[idx]
        if movie['title'] not in liked_titles_only:
            similarity_score = similarities[idx]
            recommended_movies.append((movie['title'], similarity_score))
        if len(recommended_movies) >= 5:
            break

    print("\nRecommended Movies with Similarity Scores:")
    for title, score in recommended_movies:
        print(f"- {title} (Similarity: {score:.4f})")


for user_name, liked_movies in users.items():
    recommend_for_user(user_name, liked_movies)